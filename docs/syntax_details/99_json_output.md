# GRAM JSON Output Reference

This document describes the structure of the JSON object generated by the GRAM parser. This JSON is designed to be **minified** and **registry-based** to reduce data redundancy and optimize payload size for front-end applications.

## 1. Global Structure

The root object contains the following keys:

```json
{
  "title": "Recipe Title",
  "slug": "recipe-title",
  "meta": { ... },         // Frontmatter data
  "registry": { ... },     // Definitions of ingredients/cookware
  "shopping_list": [ ... ],// Aggregated list for shopping
  "cookware": [ ... ],     // Aggregated cookware list
  "sections": [ ... ],     // The cooking steps and local ingredient usage
  "warnings": [ ... ]      // Parsing warnings (if any)
}
```

---

## 2. The Registry (`registry`)

The registry is a dictionary (Map) where keys are **Semantic IDs** (kebab-case slugs) and values are the **Static Definitions** of items. The rest of the JSON (sections, shopping list) refers to these items by their `id`.

```json
"registry": {
  "ingredients": {
    "flour": {
      "id": "flour",
      "name": "flour",
      "default_unit": "g"  // Inferred from usage if consistent
    },
    "sugar": {
      "id": "sugar",
      "name": "sugar"
    }
  },
  "cookware": {
    "pan": {
      "id": "pan",
      "name": "pan"
    }
  }
}
```

---

## 3. Minified Usage Objects

Whenever an ingredient or utensil is **used** (in a step or list), strictly minified object is used. It contains *only* the dynamic data for that specific occurrence.

### Schema

| Key | Type | Description |
| :--- | :--- | :--- |
| `id` | `string` | **Required**. Matches a key in the Registry. |
| `qty` | `number` \| `object` | The quantity. Flattened to a number if simple. |
| `unit` | `string` | The unit string (e.g., "g", "ml"). |
| `preparation` | `string` | Text from parenthesis `(chopped)`. |
| `modifiers` | `string[]` | Array of flags: `"optional"`, `"reference"`, `"hidden"`, `"bakers_percentage"`. |
| `fixed` | `boolean` | Transformation flag. **Ingredients**: `true` if fixed (default false). **Cookware**: `false` if scalable (default true). |
| `hidden` | `boolean` | `true` if marked with `-`. |
| `formula` | `object` | *Optional*. Contains raw relative formula data: `{ raw, target, percent, isGhost }`. `isGhost` is true if the target reference was not found. |

**Note:** The `type` property (e.g. `"ingredient"`) is **removed** from these objects to save space. The context (list it appears in) implies the type.

### Example

GRAM: `@garlic{2}(minced)`

JSON:
```json
{
  "id": "garlic",
  "qty": 2,
  "preparation": "minced"
}
```

---

## 4. Sections & Steps

Recipe logic is strictly hierarchical: `Sections -> Steps -> Content`.

```json
"sections": [
  {
    "title": "Dough",
    "retro_planning": "2d", // Optional: from {T-2d} in header
    "ingredients": [ ... ], // List of unique ingredients used in this section
    "steps": [
      {
        "type": "step",
        "action": "Mix",    // Optional action verb
        "content": [        // Polymorphic Array
          "Combine the ",
          { "id": "flour", "qty": 200, "unit": "g" },
          " and ",
          { "id": "water", "qty": 100, "unit": "ml" },
          " in a bowl."
        ]
      }
    ]
  }
]
```

### Polymorphic Content
The `steps[].content` array mixes:
1.  **Strings**: For plain narrative text.
2.  **Objects**: For Ingredients, Cookware, Timers (`type: timer`), Temperatures (`type: temperature`), or References (`type: reference`).

---

## 5. Shopping List

The `shopping_list` array contains the **aggregated** requirements for the whole recipe.
The structure is optimized for display.

### Schema

| Key | Type | Description |
| :--- | :--- | :--- |
| `id` | `string` | Semantic ID. |
| `qty` | `number` | The "Certain Mass", useful for scaling/graphing. (Replaces `total_mass`) |
| `unit` | `string` | The unit for the certain mass (usually 'g'). |
| `variable_entries`| `string[]`| The list of logic strings (mixed units, relative quantities) that couldn't be summed into the main mass. |


*   **Example Item:**
    ```json
    {
      "id": "sugar",
      "qty": 50,
      "unit": "g",
      "variable_entries": ["(10% of @flour)"]
    }
    ```

*   **Alternatives**
    ```json
    {
      "type": "alternative",
      "options": [ { "id": "milk" }, { "id": "water" } ]
    }
    ```

*   **Composites**
    ```json
  {
      "type": "composite",
      "id": "lemon",
      "qty": 1,
      "usage": [
        {
          "id": "zest",
          "qty": 1
        }
      ]
    }
    ```

---

## 6. Full Example

**Input (.gram)**
```gram
[Mix] @flour{100} and @sugar{50}.
```

**Output (.json)**
```json
{
  "registry": {
    "ingredients": {
      "flour": { "id": "flour", "name": "flour" },
      "sugar": { "id": "sugar", "name": "sugar" }
    }
  },
  "sections": [
    {
      "steps": [
        {
          "type": "step",
          "action": "Mix",
          "content": [
            { "id": "flour", "qty": 100 },
            " and ",
            { "id": "sugar", "qty": 50 },
            "."
          ]
        }
      ]
    }
  ]
}
```
